--------Added to Lex:----------

//Assignment 4
  | "&&"            { AND }
  | "||"            { OR }

//Assignment 5
    | "fun"   -> FUN
    | "->"            { ARROW }

//Jan 2017 Print:
    | "print" -> PRINT

//Jan 2017 Pipes:
  | "|>"            { PIPERIGHT }    
  | ">>"            { COMPOSERIGHT }

//Jan 2022 Sets:
  | ','             { COMMA }
  | "++"            { UNION }
  | '{'             { LBRACE }
  | '}'             { RBRACE }

--------Added to Yacc:----------    
//Assignment 4 (Bem√¶rk List support, er fjernet grundet gav shift/reduce conflict med andre regler)
%left AND OR             /* Assignment4  */
%type <string list> StringList
StringList:
    NAME                                  { [$1]                   }
  | NAME StringList                       { $1 :: $2               }
;
ExprList:
    AtExpr                                { [$1]                   }
  | AtExpr ExprList                       { $1 :: $2               }
;
AppExpr:
    AtExpr ExprList                       { Call($1, $2)           }
  | AppExpr ExprList                      { Call($1, $2)           }
;
  | LET NAME StringList EQ Expr IN Expr END   { Letfun($2, $3, $5, $7) }

//Assignment 5
%right ARROW
  | FUN NAME ARROW Expr                 { Fun($2, $4)            }

//Jan 2017 Print:
%left PRINT
  | PRINT Expr                          { Print($2)              }

//Jan 2017 Pipes:
%left PIPERIGHT COMPOSERIGHT
  | Expr PIPERIGHT Expr                 { Prim("|>", $1, $3)     }
  | Expr COMPOSERIGHT Expr              { Prim(">>", $1, $3)     }

//Jan 2022 Sets:
%left UNION
%type <Absyn.expr list> SetExpr
SetExpr:
    Expr                                 { [$1]                  }
  | SetExpr COMMA Expr                   { $1 @ [$3]             }
;
Expr:
  | Expr UNION Expr                     { Prim("++", $1, $3)     } /* 2022 Jan  */
  | LBRA SetExpr RBRA                   { Set($2)                }

--------Added to HigherFun:----------
//Assignment 5
Value:
  | Clos of string * expr * value env (* (x,body,declEnv) *)
Eval:
    | Fun(variable, body) ->
        Clos(variable, body, env)
| Call(eFun, eArg) -> 
      | Clos (x, body, declEnv) ->
        let xVal = eval eArg env
        let bodyEnv = (x, xVal) :: declEnv
        eval body bodyEnv        
 
//Jan 2017 Print:
| Print pn ->
      let valueOfe = eval pn env
      printfn "%A" valueOfe
      valueOfe

//Jan 2022 Sets:
value:
  | SetV of Set<value> (* 2022 JAN *)

eval:
    | Prim(ope,e1,2)
      | ("++", SetV s1, SetV s2) -> SetV (Set.union s1 s2)  (* 2022 JAN - union two sets *)
      | ("=", SetV s1, SetV s2) -> Int (if s1 = s2 then 1 else 0) (* 2022 JAN - are sets equal? *)
    | Set setLst -> SetV (Set.ofList (List.map (fun elementInList -> eval elementInList env) setLst)) (* 2022 JAN - evaluate set *) 

        
---------Commands to test code----------
    //Assignment 4:
fslex --unicode FunLex.fsl; if ($?) { fsyacc --module FunPar FunPar.fsy }
dotnet fsi -r C:\Users\jgrum\Documents\Programming\FSharp\LexAndYacc\FsLexYacc.Runtime.dll Absyn.fs FunPar.fs FunLex.fs Parse.fs Fun.fs ParseAndRun.fs

open ParseAndRun;;
fromString "3>4 || 3<4";;

    //Assignment 5:
fslex --unicode FunLex.fsl; if ($?) { fsyacc --module FunPar FunPar.fsy }
dotnet fsi -r C:\Users\jgrum\Documents\Programming\FSharp\LexAndYacc\FsLexYacc.Runtime.dll Absyn.fs FunPar.fs FunLex.fs Parse.fs HigherFun.fs ParseAndRunHigher.fs

open ParseAndRunHigher;;
run (fromString "fun x -> x + 2");;

    //Jan 2017 Print:
fslex --unicode FunLex.fsl; if ($?) { fsyacc --module FunPar FunPar.fsy }
dotnet fsi -r C:\Users\jgrum\Documents\Programming\FSharp\LexAndYacc\FsLexYacc.Runtime.dll Absyn.fs FunPar.fs FunLex.fs Parse.fs HigherFun.fs ParseAndRunHigher.fs

open ParseAndRunHigher;;
run(fromString "let f x = x + 1 in print f end");;
let ex5 = fromString "let square x = x*x in print (square 10) end";;

    //Jan 2017 Pipes:
fslex --unicode FunLex.fsl; if ($?) { fsyacc --module FunPar FunPar.fsy }
dotnet fsi -r C:\Users\jgrum\Documents\Programming\FSharp\LexAndYacc\FsLexYacc.Runtime.dll Absyn.fs FunPar.fs FunLex.fs Parse.fs HigherFun.fs ParseAndRunHigher.fs

open ParseAndRunHigher;;
let ex5 = fromString "let f x = x + 1 in 2 |> f end";;

    //Jan 2022 Sets:
fslex --unicode FunLex.fsl; if ($?) { fsyacc --module FunPar FunPar.fsy }
dotnet fsi -r C:\Users\jgrum\Documents\Programming\FSharp\LexAndYacc\FsLexYacc.Runtime.dll Absyn.fs FunPar.fs FunLex.fs Parse.fs HigherFun.fs ParseAndRunHigher.fs

open ParseAndRunHigher;;
fromString @"let s1 = {2, 3} in let s2 = {1, 4} in s1 ++ s2 = {2,4,3,1} end end";;